(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{540:function(t,s,a){"use strict";a.r(s);var e=a(8),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"/images/2019/12/01/10.jpg",alt:"",width:"1060",height:"596",loading:"lazy"}})]),t._v(" "),a("h3",{attrs:{id:"_2019-09-10-usememo-react-memo-shouldcomponentupdate-purecomponent-应用场景-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-10-usememo-react-memo-shouldcomponentupdate-purecomponent-应用场景-✅"}},[t._v("#")]),t._v(" 2019-09-10: useMemo, React.memo, shouldComponentUpdate, PureComponent 应用场景 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("一句话")])]),t._v(" "),a("ul",[a("li",[t._v("useMemo\n"),a("ul",[a("li",[t._v("适用于函数式组件")]),t._v(" "),a("li",[t._v("用来缓存计算值，依赖更新后重新计算")]),t._v(" "),a("li",[t._v("demo")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" memoizedValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("computeExpensiveValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[t._v("React.memo\n"),a("ul",[a("li",[t._v("适用于函数式组件")]),t._v(" "),a("li",[t._v("demo")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyComponent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 使用 props 渲染 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("areEqual")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("prevProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextProps")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyComponent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" areEqual"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[t._v("PureComponent\n"),a("ul",[a("li",[t._v("React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。")])])])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-09-什么是-react-suspense-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-09-什么是-react-suspense-✅"}},[t._v("#")]),t._v(" 2019-09-09: 什么是 React Suspense? ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("参考链接")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/concurrent-mode-reference.html#suspense",target:"_blank",rel:"noopener noreferrer"}},[t._v("Suspense API"),a("OutboundLink")],1)])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("一句话")])]),t._v(" "),a("ul",[a("li",[t._v("Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。")])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-08-什么是-react-profiler-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-08-什么是-react-profiler-✅"}},[t._v("#")]),t._v(" 2019-09-08: 什么是 React Profiler? ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("参考链接")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/profiler.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Profiler API"),a("OutboundLink")],1)])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("一句话")])]),t._v(" "),a("ul",[a("li",[t._v("Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分，并从相关优化中获益。")]),t._v(" "),a("li",[t._v("Profiling 增加了额外的开支，所以它在生产构建中会被禁用。")]),t._v(" "),a("li",[t._v("onRender 回调")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onRenderCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 发生提交的 Profiler 树的 “id”")]),t._v("\n  phase"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "mount" （如果组件树刚加载） 或者 "update" （如果它重渲染了）之一')]),t._v("\n  actualDuration"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 本次更新 committed 花费的渲染时间")]),t._v("\n  baseDuration"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 估计不使用 memoization 的情况下渲染整颗子树需要的时间")]),t._v("\n  startTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 本次更新中 React 开始渲染的时间")]),t._v("\n  commitTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 本次更新中 React committed 的时间")]),t._v("\n  interactions "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 属于本次更新的 interactions 的集合")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 合计或记录渲染时间。。。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-07-webpack-中的-chunks-是什么-和-bundle-有何区别-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-07-webpack-中的-chunks-是什么-和-bundle-有何区别-✅"}},[t._v("#")]),t._v(" 2019-09-07: webpack 中的 chunks 是什么？和 bundle 有何区别？ ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[t._v("bundle: 由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本")]),t._v(" "),a("li",[t._v("chunk: 这是 webpack 特定的术语被用在内部来管理 building 过程。bundle 由 chunk 组成，其中有几种类型（例如，入口 chunk(entry chunk) 和子 chunk(child chunk)）。通常 chunk 会直接对应所输出的 bundle，但是有一些配置并不会产生一对一的关系")])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-06-什么是函数式编程-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-06-什么是函数式编程-✅"}},[t._v("#")]),t._v(" 2019-09-06: 什么是函数式编程 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[t._v('"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。')]),t._v(" "),a("li",[t._v('它属于"结构化编程"的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。')]),t._v(" "),a("li",[t._v("特点\n"),a("ul",[a("li",[t._v('函数是"第一等公民"')]),t._v(" "),a("li",[t._v('只用"表达式"，不用"语句"')]),t._v(" "),a("li",[t._v('没有"副作用"')]),t._v(" "),a("li",[t._v("不修改状态")]),t._v(" "),a("li",[t._v("引用透明")])])]),t._v(" "),a("li",[t._v("意义\n"),a("ul",[a("li",[t._v("代码简洁，开发快速")]),t._v(" "),a("li",[t._v("接近自然语言，易于理解")]),t._v(" "),a("li",[t._v("更方便的代码管理")]),t._v(" "),a("li",[t._v('易于"并发编程"')]),t._v(" "),a("li",[t._v("代码的热升级")])])])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-05-浏览器内置-intl-有哪些方法-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-05-浏览器内置-intl-有哪些方法-✅"}},[t._v("#")]),t._v(" 2019-09-05: 浏览器内置 "),a("code",[t._v("Intl")]),t._v(" 有哪些方法 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Intl.Collator")])]),t._v(" "),a("li",[a("code",[t._v("Intl.DateTimeFormat")])]),t._v(" "),a("li",[a("code",[t._v("Intl.ListFormat")])]),t._v(" "),a("li",[a("code",[t._v("Intl.NumberFormat")])]),t._v(" "),a("li",[a("code",[t._v("Intl.PluralRules")])]),t._v(" "),a("li",[a("code",[t._v("Intl.RelativeTimeFormat")])])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-04-children-和-childnodes-的区别-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-04-children-和-childnodes-的区别-✅"}},[t._v("#")]),t._v(" 2019-09-04: children 和 childNodes 的区别 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[t._v("children：返回父元素所有的直系子节点的集合，注意，children 只返回 HTML 元素节点，不包括文本节点和属性节点")]),t._v(" "),a("li",[t._v("childNodes：返回父元素所有的直系子节点的集合，注意，与 children 不同的是，childNodes 会返回 HTML 元素节点，属性节点，文本节点")])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-03-什么是-redis-和数据库的区别-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-03-什么是-redis-和数据库的区别-✅"}},[t._v("#")]),t._v(" 2019-09-03: 什么是 redis，和数据库的区别 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[t._v("REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。")]),t._v(" "),a("li",[t._v("Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。")]),t._v(" "),a("li",[t._v("它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。")]),t._v(" "),a("li",[t._v("特性：速度快、数据结构、持久化、自动操作、支持多种编程语言")]),t._v(" "),a("li",[t._v("Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式")])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-02-https-通信端口-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-02-https-通信端口-✅"}},[t._v("#")]),t._v(" 2019-09-02: https 通信端口 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一句话")]),t._v(" "),a("ul",[a("li",[t._v("443: 验证证书合法性")]),t._v(" "),a("li",[t._v("80: 验证证书合法后用来传输数据")])])])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2019-09-01-浏览器-css-选择器解析顺序-✅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-09-01-浏览器-css-选择器解析顺序-✅"}},[t._v("#")]),t._v(" 2019-09-01: 浏览器 CSS 选择器解析顺序 ✅")]),t._v(" "),a("details",[a("summary",[t._v("好好想想先 😌 ")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("参考链接")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.im/entry/5a123c55f265da432240cc90",target:"_blank",rel:"noopener noreferrer"}},[t._v("探究 CSS 解析原理"),a("OutboundLink")],1)])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("一句话")])]),t._v(" "),a("ul",[a("li",[t._v("从上往下，从右往左解析")])])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);